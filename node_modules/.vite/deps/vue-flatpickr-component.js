import {
  esm_default
} from "./chunk-ZW7JNJGT.js";
import "./chunk-Y5FM7F2L.js";
import {
  defineComponent,
  h,
  nextTick
} from "./chunk-WQLFMT26.js";
import "./chunk-EWTE5DHJ.js";

// node_modules/vue-flatpickr-component/dist/esm/events.js
var includedEvents = [
  "onChange",
  "onClose",
  "onDestroy",
  "onMonthChange",
  "onOpen",
  "onYearChange"
];
var excludedEvents = [
  "onValueUpdate",
  "onDayCreate",
  "onParseConfig",
  "onReady",
  "onPreCalendarPosition",
  "onKeyDown"
];

// node_modules/vue-flatpickr-component/dist/esm/util.js
function camelToKebab(string) {
  return string.replace(/([a-z])([A-Z])/g, "$1-$2").toLowerCase();
}
function arrayify(obj) {
  return obj instanceof Array ? obj : [obj];
}
function nullify(value) {
  return value && value.length ? value : null;
}

// node_modules/vue-flatpickr-component/dist/esm/component.js
var allEvents = [...includedEvents, ...excludedEvents];
var configCallbacks = ["locale", "showMonths"];
var component_default = defineComponent({
  name: "FlatPickr",
  compatConfig: {
    MODE: 3
  },
  render() {
    return h("input", {
      type: "text",
      "data-input": true,
      disabled: this.disabled,
      onInput: this.onInput
    });
  },
  emits: [
    "blur",
    "update:modelValue",
    ...allEvents.map(camelToKebab)
  ],
  props: {
    modelValue: {
      type: [String, Number, Date, Array, null],
      required: true
    },
    // https://flatpickr.js.org/options/
    config: {
      type: Object,
      default: () => ({
        defaultDate: null,
        wrap: false
      })
    },
    events: {
      type: Array,
      default: () => includedEvents
    },
    disabled: {
      type: Boolean,
      default: false
    }
  },
  data() {
    return {
      fp: null
      //todo make it non-reactive
    };
  },
  mounted() {
    if (this.fp)
      return;
    this.fp = esm_default(this.getElem(), this.prepareConfig());
    this.fpInput().addEventListener("blur", this.onBlur);
    this.$watch("disabled", this.watchDisabled, {
      immediate: true
    });
  },
  methods: {
    prepareConfig() {
      let safeConfig = Object.assign({}, this.config);
      this.events.forEach((hook) => {
        let globalCallbacks = esm_default.defaultConfig[hook] || [];
        let localCallback = (...args) => {
          this.$emit(camelToKebab(hook), ...args);
        };
        safeConfig[hook] = arrayify(safeConfig[hook] || []).concat(globalCallbacks, localCallback);
      });
      const onCloseCb = this.onClose.bind(this);
      safeConfig["onClose"] = arrayify(safeConfig["onClose"] || []).concat(onCloseCb);
      safeConfig.defaultDate = this.modelValue || safeConfig.defaultDate;
      return safeConfig;
    },
    /**
     * Get the HTML node where flatpickr to be attached
     * Bind on parent element if wrap is true
     */
    getElem() {
      return this.config.wrap ? this.$el.parentNode : this.$el;
    },
    /**
     * Watch for value changed by date-picker itself and notify parent component
     */
    onInput(event) {
      const input = event.target;
      nextTick().then(() => {
        this.$emit("update:modelValue", nullify(input.value));
      });
    },
    fpInput() {
      return this.fp.altInput || this.fp.input;
    },
    /**
     * Blur event is required by many validation libraries
     */
    onBlur(event) {
      this.$emit("blur", nullify(event.target.value));
    },
    /**
     * Flatpickr does not emit input event in some cases
     */
    onClose(selectedDates, dateStr) {
      this.$emit("update:modelValue", dateStr);
    },
    /**
     * Watch for the disabled property and sets the value to the real input.
     */
    watchDisabled(newState) {
      if (newState) {
        this.fpInput().setAttribute("disabled", "");
      } else {
        this.fpInput().removeAttribute("disabled");
      }
    }
  },
  watch: {
    /**
     * Watch for any config changes and redraw date-picker
     */
    config: {
      deep: true,
      handler(newConfig) {
        if (!this.fp)
          return;
        let safeConfig = Object.assign({}, newConfig);
        allEvents.forEach((hook) => {
          delete safeConfig[hook];
        });
        this.fp.set(safeConfig);
        configCallbacks.forEach((name) => {
          if (typeof safeConfig[name] !== "undefined") {
            this.fp.set(name, safeConfig[name]);
          }
        });
      }
    },
    /**
     * Watch for changes from parent component and update DOM
     */
    modelValue(newValue) {
      var _a;
      if (!this.$el || newValue === nullify(this.$el.value))
        return;
      (_a = this.fp) === null || _a === void 0 ? void 0 : _a.setDate(newValue, true);
    }
  },
  beforeUnmount() {
    if (!this.fp)
      return;
    this.fpInput().removeEventListener("blur", this.onBlur);
    this.fp.destroy();
    this.fp = null;
  }
});

// node_modules/vue-flatpickr-component/dist/esm/index.js
var esm_default2 = component_default;
export {
  esm_default2 as default
};
//# sourceMappingURL=vue-flatpickr-component.js.map
